var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = AMDocs","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Fourier-Transforms","page":"API","title":"Fourier Transforms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AcousticMetrics.rfft!\nAcousticMetrics.irfft!","category":"page"},{"location":"api/#AcousticMetrics.rfft!","page":"API","title":"AcousticMetrics.rfft!","text":"rfft!(y, x, cache=nothing)\n\nCalculate the real-input FFT of `x` and store the result in half-complex format in `y`.\n\nJust a wrapper of `FFTW.r2r!(y, FFTW.R2HC)`. The `cache` argument is\noptional and not used, and is included to keep the function signiture the\nsame as the method that takes `Vector`s of `Dual`s.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.irfft!","page":"API","title":"AcousticMetrics.irfft!","text":"irfft!(y, x, cache=nothing)\n\nCalculate the inverse FFT of `x` and store the result in in `y`, where `x` is in the half-complex format.\n\nJust a wrapper of `FFTW.r2r!(y, FFTW.HC2R)`. The `cache` argument is\noptional and not used, and is included to keep the function signiture the\nsame as the method that takes `Vector`s of `Dual`s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pressure-Time-History","page":"API","title":"Pressure Time History","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractPressureTimeHistory\nPressureTimeHistory\nAcousticMetrics.pressure\nAcousticMetrics.inputlength\nAcousticMetrics.timestep(pth::AbstractPressureTimeHistory)\nAcousticMetrics.starttime(pth::AbstractPressureTimeHistory)\nAcousticMetrics.time","category":"page"},{"location":"api/#AcousticMetrics.AbstractPressureTimeHistory","page":"API","title":"AcousticMetrics.AbstractPressureTimeHistory","text":"AbstractPressureTimeHistory{IsEven}\n\nSupertype for a pressure time history, i.e., pressure as a function of time defined on evenly-spaced time samples.\n\nThe IsEven parameter is a Bool indicating if the length of the pressure time history is even or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureTimeHistory","page":"API","title":"AcousticMetrics.PressureTimeHistory","text":"PressureTimeHistory{IsEven} <: AbstractPressureTimeHistory{IsEven}\n\nPressure as a function of time defined on evenly-spaced time samples.\n\nThe IsEven parameter is a Bool indicating if the length of the pressure time history is even or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.pressure","page":"API","title":"AcousticMetrics.pressure","text":"pressure(pth::AbstractPressureTimeHistory)\n\nReturn a vector of pressures associated with a pressure time history.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.inputlength","page":"API","title":"AcousticMetrics.inputlength","text":"inputlength(pth::AbstractPressureTimeHistory)\n\nReturn a number of pressure samples associated with a pressure time history.\n\n\n\n\n\ninputlength(sm::AbstractNarrowbandSpectrum)\n\nReturn a number of pressure time samples associated with a narrowband spectrum.\n\nThis is also the length of the discrete Fourier transform associated with the spectrum in half-complex format.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.timestep-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.timestep","text":"timestep(pth::AbstractPressureTimeHistory)\n\nReturn the time step size dt associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.starttime-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.starttime","text":"starttime(pth::AbstractPressureTimeHistory)\n\nReturn the initial time t0 associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.time","page":"API","title":"AcousticMetrics.time","text":"time(pth::AbstractPressureTimeHistory)\n\nReturn a vector of times associated with a pressure time history.\n\n\n\n\n\n","category":"function"},{"location":"api/#Narrowband-Metrics","page":"API","title":"Narrowband Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractNarrowbandSpectrum\nAcousticMetrics.halfcomplex\nAcousticMetrics.timestep(sm::AbstractNarrowbandSpectrum)\nAcousticMetrics.starttime(sm::AbstractNarrowbandSpectrum)\nAcousticMetrics.samplerate\nAcousticMetrics.frequency\nAcousticMetrics.frequencystep\nAcousticMetrics.istonal\nPressureSpectrumAmplitude\nPressureSpectrumPhase\nMSPSpectrumAmplitude\nMSPSpectrumPhase\nPowerSpectralDensityAmplitude\nPowerSpectralDensityPhase","category":"page"},{"location":"api/#AcousticMetrics.AbstractNarrowbandSpectrum","page":"API","title":"AcousticMetrics.AbstractNarrowbandSpectrum","text":"AbstractNarrowbandSpectrum{IsEven,IsTonal,Tel} <: AbstractVector{Tel}\n\nSupertype for a generic narrowband acoustic metric which will behave as an immutable AbstractVector of element type Tel.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated. IsTonal indicates how the acoustic energy is distributed through the frequency bands:\n\nIsTonal == false means the acoustic energy is assumed to be evenly distributed thoughout each band\nIsTonal == true means the acoustic energy is assumed to be concentrated at each band center\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.halfcomplex","page":"API","title":"AcousticMetrics.halfcomplex","text":"halfcomplex(sm::AbstractNarrowbandSpectrum)\n\nReturn a vector of the discrete Fourier transform of the pressure time history in half-complex format.\n\nSee the FFTW docs for the definition of the halfcomplex format.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.timestep-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.timestep","text":"timestep(sm::AbstractNarrowbandSpectrum)\n\nReturn the time step size dt associated with a narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.starttime-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.starttime","text":"starttime(sm::AbstractNarrowbandSpectrum)\n\nReturn the initial time t0 associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.samplerate","page":"API","title":"AcousticMetrics.samplerate","text":"samplerate(sm::AbstractNarrowbandSpectrum)\n\nReturn the sample rate (aka the inverse of the time step size) associated with a narrowband spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.frequency","page":"API","title":"AcousticMetrics.frequency","text":"frequency(sm::AbstractNarrowbandSpectrum)\n\nReturn a vector of frequencies associated with the narrowband spectrum.\n\nThe frequencies are calculated using the rfftfreq function in the FFTW.jl package.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.frequencystep","page":"API","title":"AcousticMetrics.frequencystep","text":"frequencystep(sm::AbstractNarrowbandSpectrum)\n\nReturn the frequency step size Δf associated with the narrowband spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.istonal","page":"API","title":"AcousticMetrics.istonal","text":"istonal(sm::AbstractNarrowbandSpectrum)\n\nReturn true if the spectrum is tonal, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.PressureSpectrumAmplitude","page":"API","title":"AcousticMetrics.PressureSpectrumAmplitude","text":"PressureSpectrumAmplitude{IsEven,IsTonal,Tel} <: AbstractNarrowbandSpectrum{IsEven,IsTonal,Tel}\n\nRepresentation of acoustic pressure amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated. The IsTonal Bool parameter, if true, indicates the pressure spectrum is tonal and thus concentrated at discrete frequencies. If false, the spectrum is assumed to be constant over each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumPhase","page":"API","title":"AcousticMetrics.PressureSpectrumPhase","text":"PressureSpectrumPhase{IsEven,IsTonal,Tel} <: AbstractNarrowbandSpectrum{IsEven,IsTonal,Tel}\n\nRepresentation of acoustic pressure phase as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated. The IsTonal Bool parameter, if true, indicates the phase spectrum is tonal and thus concentrated at discrete frequencies. If false, the spectrum is assumed to be constant over each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumAmplitude","page":"API","title":"AcousticMetrics.MSPSpectrumAmplitude","text":"MSPSpectrumAmplitude{IsEven,IsTonal,Tel} <: AbstractNarrowbandSpectrum{IsEven,IsTonal,Tel}\n\nRepresentation of mean-squared pressure amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated. The IsTonal Bool parameter, if true, indicates the mean-squared pressure spectrum is tonal and thus concentrated at discrete frequencies. If false, the pressure spectrum is assumed to be constant over each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumPhase","page":"API","title":"AcousticMetrics.MSPSpectrumPhase","text":"MSPSpectrumPhase\n\nAlias for PressureSpectrumPhase.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityAmplitude","page":"API","title":"AcousticMetrics.PowerSpectralDensityAmplitude","text":"PowerSpectralDensityAmplitude{IsEven,Tel} <: AbstractNarrowbandSpectrum{IsEven,false,Tel}\n\nRepresentation of acoustic power spectral density amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated. As the power spectral density is not well-defined for tones, the IsTonal parameter is always false.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityPhase","page":"API","title":"AcousticMetrics.PowerSpectralDensityPhase","text":"PowerSpectralDensityPhase\n\nAlias for PressureSpectrumPhase.\n\n\n\n\n\n","category":"type"},{"location":"api/#Proportional-Bands-and-Proportional-Band-Spectra","page":"API","title":"Proportional Bands and Proportional Band Spectra","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractProportionalBands\nAcousticMetrics.octave_fraction\nAcousticMetrics.lower_center_upper\nAcousticMetrics.freq_scaler\nAcousticMetrics.band_start\nAcousticMetrics.band_end\nAcousticMetrics.lower_bands\nAcousticMetrics.upper_bands\nAcousticMetrics.center_bands\nAcousticMetrics.cband_number\nExactProportionalBands\nExactOctaveCenterBands\nExactOctaveLowerBands\nExactOctaveUpperBands\nExactThirdOctaveCenterBands\nExactThirdOctaveLowerBands\nExactThirdOctaveUpperBands\nApproximateThirdOctaveBands\nApproximateThirdOctaveCenterBands\nApproximateThirdOctaveLowerBands\nApproximateThirdOctaveUpperBands\nApproximateOctaveBands\nApproximateOctaveCenterBands\nApproximateOctaveLowerBands\nApproximateOctaveUpperBands\nAbstractProportionalBandSpectrum\nAcousticMetrics.has_observer_time\nAcousticMetrics.observer_time\nAcousticMetrics.timestep(pbs::AbstractProportionalBandSpectrum)\nAcousticMetrics.amplitude\nAcousticMetrics.time_period\nAcousticMetrics.time_scaler\nLazyNBProportionalBandSpectrum\nAcousticMetrics.frequency_nb\nAcousticMetrics.lazy_pbs\nProportionalBandSpectrum\nLazyPBSProportionalBandSpectrum\nProportionalBandSpectrumWithTime\nAcousticMetrics.combine","category":"page"},{"location":"api/#AcousticMetrics.AbstractProportionalBands","page":"API","title":"AcousticMetrics.AbstractProportionalBands","text":"AbstractProportionalBands{NO,LCU,TF} <: AbstractVector{TF}\n\nAbstract type representing the exact proportional frequency bands with band fraction NO and eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.octave_fraction","page":"API","title":"AcousticMetrics.octave_fraction","text":"octave_fraction(bands::AbstractProportionalBands{NO}) where {NO}\n\nReturn NO, the \"octave fraction,\" e.g. 1 for octave bands, 3 for third-octave, 12 for twelfth-octave.\n\n\n\n\n\noctave_fraction(pbs::AbstractProportionalBandSpectrum{NO}) where {NO}\n\nReturn NO, the \"octave fraction,\" e.g. 1 for octave bands, 3 for third-octave, 12 for twelfth-octave.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.lower_center_upper","page":"API","title":"AcousticMetrics.lower_center_upper","text":"lower_center_upper(bands::AbstractProportionalBands{NO,LCU,TF}) where {NO,LCU,TF}\n\nReturn LCU, which can be either :lower, :center, :upper, indicating if bands represents the lower edges, centers, or upper edges of proportional bands, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.freq_scaler","page":"API","title":"AcousticMetrics.freq_scaler","text":"freq_scaler(bands::AbstractProportionalBands)\n\nReturn the factor each \"standard\" frequency band is scaled by.\n\nFor example, the approximate octave center bands include 1000 Hz, 2000 Hz, and 4000 Hz. If freq_scaler(bands) == 1.0, then these frequencies would be unchanged. If freq_scaler(bands) == 1.5, then bands would include 1500 Hz, 3000 Hz, and 6000 Hz instead. If freq_scaler(bands) == 0.5, then bands would include 500 Hz, 1000 Hz, and 2000 Hz in place of 1000 Hz, 2000 Hz, and 4000 Hz.\n\n\n\n\n\nfreq_scaler(pbs::AbstractProportionalBandSpectrum)\n\nReturn the factor each \"standard\" frequency band associated with the proportional band spectrum pbs is scaled by.\n\nFor example, the approximate octave center bands include 1000 Hz, 2000 Hz, and 4000 Hz. If freq_scaler(pbs) == 1.0, then these frequencies would be unchanged. If freq_scaler(pbs) == 1.5, then bands would include 1500 Hz, 3000 Hz, and 6000 Hz instead. If freq_scaler(pbs) == 0.5, then bands would include 500 Hz, 1000 Hz, and 2000 Hz in place of 1000 Hz, 2000 Hz, and 4000 Hz.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.band_start","page":"API","title":"AcousticMetrics.band_start","text":"band_start(bands::AbstractProportionalBands)\n\nReturn the standard band index number for the first band in bands.\n\nFor example, it happens that the approximate octave center bands includes 1000 Hz, and that particular band is numbered 10. So if the first band contained in bands happens to be 1000 Hz (and freq_scaler(bands) == 1.0), then band_start(bands) == 10. Not particularly useful to a user.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.band_end","page":"API","title":"AcousticMetrics.band_end","text":"band_end(bands::AbstractProportionalBands)\n\nReturn the standard band index number for the last band in bands.\n\nFor example, it happens that the approximate octave center bands includes 1000 Hz, and that particular band is numbered 10. So if the last band contained in bands happens to be 1000 Hz (and freq_scaler(bands) == 1.0), then band_end(bands) == 10. Not particularly useful to a user.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.lower_bands","page":"API","title":"AcousticMetrics.lower_bands","text":"lower_bands(TBands::Type{<:AbstractProportionalBands{NO}}, fstart::TF, fend::TF, scaler=1) where {NO,TF} \n\nConstruct and return the lower edges of the proportional bands TBands, scaled by scaler, that would fully encompass a frequency range beginning with fstart and ending with fend.\n\n\n\n\n\nlowerbands(bands::ExactProportionalBands{NO,LCU,TF}, scaler=freqscaler(bands)) where {NO,TF} \n\nConstruct and return the lower edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nlowerbands(bands::ApproximateThirdOctaveBands{LCU,TF}, scaler=freqscaler(bands)) where {LCU,TF}\n\nConstruct and return the lower edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nlower_bands(bands::ApproximateOctaveBands{LCU,TF}, scaler=freq_scaler(bands))\n\nConstruct and return the lower edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nlower_bands(pbs::AbstractProportionalBandSpectrum)\n\nReturn the lower edges of the proportional bands associated with the proportional band spectrum pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.upper_bands","page":"API","title":"AcousticMetrics.upper_bands","text":"upper_bands(TBands::Type{<:AbstractProportionalBands{NO}}, fstart::TF, fend::TF, scaler=1) where {NO,TF} \n\nConstruct and return the upper edges of the proportional bands TBands, scaled by scaler, that would fully encompass a frequency range beginning with fstart and ending with fend.\n\n\n\n\n\nupperbands(bands::ExactProportionalBands{NO,LCU,TF}, scaler=freqscaler(bands)) where {NO,TF} \n\nConstruct and return the upper edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nupperbands(bands::ApproximateThirdOctaveBands{LCU,TF}, scaler=freqscaler(bands)) where {LCU,TF}\n\nConstruct and return the upper edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nupper_bands(bands::ApproximateOctaveBands{LCU,TF}, scaler=freq_scaler(bands))\n\nConstruct and return the upper edges of the proportional bands bands scaled by scaler.\n\n\n\n\n\nupper_bands(pbs::AbstractProportionalBandSpectrum)\n\nReturn the upper edges of the proportional bands associated with the proportional band spectrum pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.center_bands","page":"API","title":"AcousticMetrics.center_bands","text":"center_bands(TBands::Type{<:AbstractProportionalBands{NO}}, fstart::TF, fend::TF, scaler=1) where {NO,TF} \n\nConstruct and return the centers of the proportional bands TBands, scaled by scaler, that would fully encompass a frequency range beginning with fstart and ending with fend.\n\n\n\n\n\ncenterbands(bands::ExactProportionalBands{NO,LCU,TF}, scaler=freqscaler(bands)) where {NO,TF} \n\nConstruct and return the centers of the proportional bands bands scaled by scaler.\n\n\n\n\n\ncenterbands(bands::ApproximateThirdOctaveBands{LCU,TF}, scaler=freqscaler(bands)) where {LCU,TF}\n\nConstruct and return the centers of the proportional bands bands scaled by scaler.\n\n\n\n\n\ncenter_bands(bands::ApproximateOctaveBands{LCU,TF}, scaler=freq_scaler(bands))\n\nConstruct and return the centers of the proportional bands bands scaled by scaler.\n\n\n\n\n\ncenter_bands(pbs::AbstractProportionalBandSpectrum)\n\nReturn the centers of the proportional bands associated with the proportional band spectrum pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.cband_number","page":"API","title":"AcousticMetrics.cband_number","text":"cband_number(bands::AbstractProportionalBands, fc)\n\nReturn the standard band index number of the band with center frequency fc for proportional bands bands.\n\nFor example, if bands is a subtype of ApproximateOctaveBands and freq_scaler(bands) == 1.0, then cband_number(bands, 1000.0) == 10.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.ExactProportionalBands","page":"API","title":"AcousticMetrics.ExactProportionalBands","text":"ExactProportionalBands{NO,LCU,TF} <: AbstractProportionalBands{NO,LCU,TF}\n\nRepresentation of the exact proportional frequency bands with band fraction NO and eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactOctaveCenterBands","page":"API","title":"AcousticMetrics.ExactOctaveCenterBands","text":"ExactOctaveCenterBands{TF}\n\nAlias for ExactProportionalBands{1,:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactOctaveLowerBands","page":"API","title":"AcousticMetrics.ExactOctaveLowerBands","text":"ExactOctaveLowerBands{TF}\n\nAlias for ExactProportionalBands{1,:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactOctaveUpperBands","page":"API","title":"AcousticMetrics.ExactOctaveUpperBands","text":"ExactOctaveUpperBands{TF}\n\nAlias for ExactProportionalBands{1,:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactThirdOctaveCenterBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveCenterBands","text":"ExactThirdOctaveCenterBands{TF}\n\nAlias for ExactProportionalBands{3,:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactThirdOctaveLowerBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveLowerBands","text":"ExactThirdOctaveLowerBands{TF}\n\nAlias for ExactProportionalBands{3,:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactThirdOctaveUpperBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveUpperBands","text":"ExactThirdOctaveUpperBands{TF}\n\nAlias for ExactProportionalBands{3,:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveBands","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveBands","text":"ApproximateThirdOctaveBands{LCU,TF} <: AbstractProportionalBands{3,LCU,TF}\n\nRepresentation of the approximate third-octave proportional frequency bands with eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveCenterBands","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveCenterBands","text":"ApproximateThirdOctaveCenterBands{TF}\n\nAlias for ApproximateThirdOctaveBands{:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveLowerBands","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveLowerBands","text":"ApproximateThirdOctaveLowerBands{TF}\n\nAlias for ApproximateThirdOctaveBands{:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveUpperBands","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveUpperBands","text":"ApproximateThirdOctaveUpperBands{TF}\n\nAlias for ApproximateThirdOctaveBands{:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveBands","page":"API","title":"AcousticMetrics.ApproximateOctaveBands","text":"ApproximateOctaveBands{LCU,TF} <: AbstractProportionalBands{1,LCU,TF}\n\nRepresentation of the approximate octave proportional frequency bands with eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveCenterBands","page":"API","title":"AcousticMetrics.ApproximateOctaveCenterBands","text":"ApproximateOctaveCenterBands{TF}\n\nAlias for ApproximateOctaveBands{:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveLowerBands","page":"API","title":"AcousticMetrics.ApproximateOctaveLowerBands","text":"ApproximateOctaveLowerBands{TF}\n\nAlias for ApproximateOctaveBands{:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveUpperBands","page":"API","title":"AcousticMetrics.ApproximateOctaveUpperBands","text":"ApproximateOctaveUpperBands{TF}\n\nAlias for ApproximateOctaveBands{:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.AbstractProportionalBandSpectrum","page":"API","title":"AcousticMetrics.AbstractProportionalBandSpectrum","text":"AbstractProportionalBandSpectrum{NO,TF} <: AbstractVector{TF}\n\nAbstract type representing a proportional band spectrum with band fraction NO and eltype TF.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.has_observer_time","page":"API","title":"AcousticMetrics.has_observer_time","text":"has_observer_time(pbs::AbstractProportionalBandSpectrum)\n\nReturn true if the proportional band spectrum is defined to exist over a limited time, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.observer_time","page":"API","title":"AcousticMetrics.observer_time","text":"observer_time(pbs::AbstractProportionalBandSpectrum)\n\nReturn the observer time at which the proportional band spectrum is defined to exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.timestep-Tuple{AcousticMetrics.AbstractProportionalBandSpectrum}","page":"API","title":"AcousticMetrics.timestep","text":"timestep(pbs::AbstractProportionalBandSpectrum)\n\nReturn the time range over which the proportional band spectrum is defined to exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.amplitude","page":"API","title":"AcousticMetrics.amplitude","text":"amplitude(pbs::AbstractProportionalBandSpectrum)\n\nReturn the underlying Vector containing the proportional band spectrum amplitudes contained in pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.time_period","page":"API","title":"AcousticMetrics.time_period","text":"time_period(pbs::AbstractArray{<:AbstractProportionalBandSpectrum})\n\nFind the period of time over which the collection of proportional band spectrum pbs exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.time_scaler","page":"API","title":"AcousticMetrics.time_scaler","text":"time_scaler(pbs::AbstractProportionalBandSpectrum{NO,TF}, period)\n\nFind the scaling factor appropriate to multiply the proportional band spectrum pbs by that accounts for the duration of time the spectrum exists.\n\nThis is used when combining multiple proportional band spectra with the combine function.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.LazyNBProportionalBandSpectrum","page":"API","title":"AcousticMetrics.LazyNBProportionalBandSpectrum","text":"LazyNBProportionalBandSpectrum{NO,IsTonal,TF,TAmp,TBandsC}\n\nLazy representation of a proportional band spectrum with octave fraction NO and eltype TF constructed from a narrowband (NB) spectrum.\n\nIsTonal indicates how the acoustic energy is distributed through the narrow frequency bands:\n\nIsTonal == false means the acoustic energy is assumed to be evenly distributed thoughout each band\nIsTonal == true means the acoustic energy is assumed to be concentrated at each band center\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.frequency_nb","page":"API","title":"AcousticMetrics.frequency_nb","text":"frequency_nb(pbs::LazyNBProportionalBandSpectrum)\n\nReturn the narrowband frequencies associated with the underlying narrowband spectrum contained in pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.lazy_pbs","page":"API","title":"AcousticMetrics.lazy_pbs","text":"lazy_pbs(pbs, cbands::AbstractProportionalBands{NO,:center})\n\nConstruct a lazy proportional band spectrum on proportional center bands cbands using the proportional band spectrum pbs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.ProportionalBandSpectrum","page":"API","title":"AcousticMetrics.ProportionalBandSpectrum","text":"ProportionalBandSpectrum{NO,TF,TPBS,TBandsL,TBandsC,TBandsU}\n\nRepresentation of a proportional band spectrum with octave fraction NO and eltype TF.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.LazyPBSProportionalBandSpectrum","page":"API","title":"AcousticMetrics.LazyPBSProportionalBandSpectrum","text":"LazyPBSProportionalBandSpectrum{NO,TF} <: AbstractProportionalBandSpectrum{NO,TF}\n\nLazy representation of a proportional band spectrum with octave fraction NO and eltype TF constructed from a different proportional band spectrum.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ProportionalBandSpectrumWithTime","page":"API","title":"AcousticMetrics.ProportionalBandSpectrumWithTime","text":"ProportionalBandSpectrumWithTime{NO,TF,TPBS,TBandsC,TTime,TDTime}\n\nRepresentation of a proportional band spectrum with octave fraction NO and eltype TF, but with an observer time.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.combine","page":"API","title":"AcousticMetrics.combine","text":"combine(pbs::AbstractArray{<:AbstractProportionalBandSpectrum}, outcbands::AbstractProportionalBands{NO,:center}, time_axis=1) where {NO}\n\nCombine each input proportional band spectrum of pbs into one output proportional band spectrum using the proportional center bands indicated by outcbands.\n\ntime_axis is an integer indicating the axis of the pbs array along which time varies. For example, if time_axis == 1 and pbs is a three-dimensional array, then apth[:, i, j] would be proportional band spectrum of source i, j  for all time. But if time_axis == 3, then pbs[i, j, :] would be the proportional band spectrum of source i, j for all time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Weighting","page":"API","title":"Weighting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"W_A","category":"page"},{"location":"api/#AcousticMetrics.W_A","page":"API","title":"AcousticMetrics.W_A","text":"W_A(f::AbstractFloat)\n\nCalculate the A-weighting factor for a frequency f in Hertz.\n\nTaken from the ANOPP2 Acoustics Analysis API Reference Manual.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integrated-Metrics","page":"API","title":"Integrated Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"OASPL","category":"page"},{"location":"api/#AcousticMetrics.OASPL","page":"API","title":"AcousticMetrics.OASPL","text":"OASPL(ap::AbstractPressureTimeHistory)\n\nReturn the overall sound pressure level of a pressure time history.\n\n\n\n\n\nOASPL(ap::AbstractNarrowbandSpectrum)\n\nReturn the overall sound pressure level of a narrowband spectrum.\n\n\n\n\n\n","category":"function"},{"location":"dev/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"dev/#CompatHelper.jl,-Running-Tests,-and-Signing-Commits","page":"Developer Notes","title":"CompatHelper.jl, Running Tests, and Signing Commits","text":"","category":"section"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"CompatHelper.jl will automatically look for new versions of AcousticMetrics.jl's dependencies and, if it finds any breaking versions, open PRs with changes to AcousticMetrics.jl's Project.toml to incorporate the new versions. But! The PR won't automatically run the GitHub Action tests: https://github.com/peter-evans/create-pull-request/blob/main/docs/concepts-guidelines.md#triggering-further-workflow-runs A workaround is to manually close and immediately re-open the PR, which will run the tests and isn't too much work.","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"The next problem: commits created by CompatHelper.jl/the github-actions bot aren't signed, and AcousticMetrics.jl is set up to require signed commits when merging into the main branch. So, what to do? Check out the CompatHelper.jl PR locally, manually sign the commits, then submit a new PR with the freshly-signed commits using this procedure:","category":"page"},{"location":"dev/","page":"Developer Notes","title":"Developer Notes","text":"First, check the CompatHelper.jl PR locally: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/checking-out-pull-requests-locally?tool=cli\nNext, manually sign the CompatHelper.jl commit using git rebase: https://superuser.com/questions/397149/can-you-gpg-sign-old-commits#\nThen push the branch with the newly signed commits to my fork, and merge\nClose the CompatHelper.jl PR :-/","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"CurrentModule = AMDocs","category":"page"},{"location":"theory/#AcousticMetrics.jl","page":"Theory","title":"AcousticMetrics.jl","text":"","category":"section"},{"location":"theory/#The-Fourier-Transform","page":"Theory","title":"The Fourier Transform","text":"","category":"section"},{"location":"theory/#The-Basics","page":"Theory","title":"The Basics","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"AcousticMetrics.jl uses the FFTW library, a very popular implementation of the fast Fourier transform (FFT) algorithm. The FFT is a method of computing the discrete Fourier transform (DFT) that reduces the computational complexity from n^2 to n log(n), where n is the length of the input to the transform. FFTW's definition of the discrete Fourier transform is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  y_k = sum_j=0^n-1 x_j e^-2 pi imath jkn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where imath=sqrt-1.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The goal of a Fourier transform is to take a function (let's call it a \"signal\") and express it as a sum of sinusoids. Let's imagine we have a very simple signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we call A the amplitude, ω the frequency, and φ the phase. AcousticAnalogies.jl is interested in (surprise!) acoustics, which are real numbers, so we'll assume that A, ω, and φ are all real. Say we evaluate that function n times over a period T, and assume that ω = 2πmT, i.e., that the period of our signal is some integer fraction of the sampling period T, since","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"frac2 πω = frac2 πfrac2πmT = fracTm","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We'll refer to each of those samples as p_j = p(t_j), where t_j is the time at sample j and j is an index from 0 to n-1.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What is the discrete Fourier transform of our signal p_j? We should be able to figure that out if we can express our signal p(t) as something that looks like FFTW's definition of the DFT. How can we do that? Well, first we need to remember that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"cos(α+β) = cos(α)cos(β) - sin(α)sin(β)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which lets us rewrite our signal as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ) = Aleft cos(ωt)cos(φ) - sin(ωt)sin(φ) right = A cos(φ)cos(ωt) - Asin(φ)sin(ωt)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, if we also remember that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"e^ix = cos(x) + imath sin(x)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can replace sin(ωt) with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sin(ωt) = frace^imath ωt - e^-imath ωt2imath = frac-imath e^imath ωt + imath e^-imath ωt2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and cos(ωt) with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"cos(ωt) = frace^imath ωt + e^-imath ωt2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Throw all that together and we get","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left cos(φ) + imath sin(φ)right e^imath ωt + fracA2left cos(φ) - imath sin(φ)right e^-imath ωt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is looking much closer to the definition of the DFT that we started with. Next thing we need to do is realize that since we've sampled our signal p(t) at n different times, equally spaced, over a time period T, then we can replace t with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"t_j = j fracTn = j Δt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Tn is Δt, the time step size. We've previously said that ω=frac2πmT, which implies that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2πmT right) left(j fracTn right) = frac2πmjn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So if we throw that in there, we find","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath jmn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"That's very close to the DFT definition. So what happens if we evaluate the DFT of that last expression? We'll call the discrete Fourier transform of the signal hatp_k. So...","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath jmn + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath jmn right) e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+k)n right) \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+k)n \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Pretty close now. Let's think about those two summations in the last expression. First assume that m - k = q ne 0, where m and k are both integers. Then the first sum would be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-k)n = sum_j=0^n-1 e^2πimath jqn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"That's a signal that has period","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"frac2π2πqn = nq","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"that we're sampling n times. So we're sampling a sinusoid an integer number of times over its period, and summing it up. That will give us... zero. Same thing will happen to the second sum if m+k=r ne 0: we'll also get zero. So now we just have to figure out what happens when m - k = 0 and m + k = 0, i.e., when k  m. Let's try k = m first. The first sum will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-m)n = sum_j=0^n-1 e^0 = sum_j=0^n-1 1 = n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the second sum will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^-2πimath j(m+m)n = sum_j=0^n-1 e^-4πimath jmn = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"from the previous discussion, since m+k=2m ne 0.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For k = -m, the first sum will be zero, since m - -m = 2m ne 0, and the second sum will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-m))n = n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"again.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Great! So now we finally can write down the DFT of our example signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ) = A cosleft(leftfrac2πmTrightt+φright)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which is (wish I could figure out how to do the cases LaTeX environment)...","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/#Some-Special-Cases","page":"Theory","title":"Some Special Cases","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"There are two special cases that we need to consider: the mean component and the Nyquist component of the DFT. Let's try the mean component first.","category":"page"},{"location":"theory/#The-Mean-Component","page":"Theory","title":"The Mean Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So imagine if we start out with the same signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"but say that ω = 0. Since ω = 2πmT, that implies that m = 0 also. But anyway, let's rewrite that in terms of powers of e:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^imath ωt + fracA2leftcos(φ) - imath sin(φ) right e^-imath ωt \n     = fracA2leftcos(φ) + imath sin(φ) right e^0 + fracA2leftcos(φ) - imath sin(φ) right e^0\n     = fracA2left2cos(φ)right\n     = Acos(φ)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What happens if we plug that into the definition of the discrete Fourier transform? We'll, it's not hard to see that we'll get","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_0 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So the two takeaways are:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the mean component doesn't contain a frac12 factor\nthe mean component is always real","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Next, the Nyquist frequency component.","category":"page"},{"location":"theory/#Nyquist-Component","page":"Theory","title":"Nyquist Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Nyquist component is the one with two samples per period, which corresponds to k=n2 in the DFT definition. It is the highest frequency component that the DFT can resolve. So that means our signal will look like","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath jmn + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath jmn \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now here's where things get a bit tricky. We've got a fracn2n term that we'd love to replace with frac12. That works fine if n is even, but what if n is odd? We'll have to look at both cases. First, the even case.","category":"page"},{"location":"theory/#Nyquist-Component-with-Even-Length-Input","page":"Theory","title":"Nyquist Component with Even-Length Input","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If n is even, then we can do","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n \n     = fracA2leftcos(φ) + imath sin(φ) right e^πimath j + fracA2leftcos(φ) - imath sin(φ) right e^-πimath j\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and then realize that e^πimath j = e^-πimath j = left(-1right)^j, which let's us simplify a bit further to","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left2cos(φ)e^πimath jright = Acos(φ)e^πimath j","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next step is to think about which components of the DFT we need to worry about. If we shove that into the DFT, we'll need to just focus on the e^-2πimath j (n2)n = e^-πimath j component of the DFT, and we'll eventually end up with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_n2 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so the takeaways are identical to the mean component:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the Nyquist component for n even doesn't contain a frac12 factor\nthe Nyquist component for n even is always real","category":"page"},{"location":"theory/#Nyquist-Component-with-Odd-Length-Input","page":"Theory","title":"Nyquist Component with Odd-Length Input","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So, we're starting with ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, the trick here is that there is no Nyquist frequency component with an odd-input DFT. We'll never end up with e^2πimath j(fracn2)n = e^πimath components in the DFT definition, since n is odd. For example, if n=9, the k in the original definition of the DFT","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  y_k = sum_j=0^n-1 x_j e^-2 pi imath jkn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"will never take on the value n2, since that would be 4frac12 and k is an integer. So this special case isn't special for odd input lengths.","category":"page"},{"location":"theory/#Order-of-Outputs","page":"Theory","title":"Order of Outputs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We're almost ready to compare our example signal to the output of the FFTW library. The last thing we need to think about is how FFTW's output is ordered. FFT libraries have different conventions, but here is what FFTW does:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note also that we use the standard “in-order” output ordering—the k-th output corresponds to the frequency k/n (or k/T, where T is your total sampling period). For those who like to think in terms of positive and negative frequencies, this means that the positive frequencies are stored in the first half of the output and the negative frequencies are stored in backwards order in the second half of the output. (The frequency -k/n is the same as the frequency (n-k)/n.)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So for our original example signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p(t) = A cos(ωt+φ) \n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we would expect hatp_m to appear in the 1+m position (since m starts from 0, but the first \"position\" is 1 for Julia arrays), and hatp_-m to appear in the 1+n-m position. But things get a bit more complicated if we use a real-input FFT (which AcousticMetrics.jl does). See the next section.","category":"page"},{"location":"theory/#Real-Input-FFTs-and-Half-Complex-Format","page":"Theory","title":"Real-Input FFTs and Half-Complex Format","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we look back at the results for the DFT of our simple signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p(t) = A cos(ωt+φ) \n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can't help but notice that the negative and positive frequency results are closely related. If we know one, we can figure out the other. And if we want to find A and φ, we just need either the positive or negative result. For example, if a_r and a_i are the real and imaginary parts of hatp_m, respectively, then","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = frac2nsqrta_r^2 + a_i^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = arctan(a_ia_r)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the Nyquist frequency, though, we know that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_n2 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so a_r = Acos(φ)n and a_i = 0. We have only one non-zero component, so we'll have to define ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = a_rn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Or, wait, maybe it would be better to make A = abs(a_r)/n and φ = π if a_r < 0, and φ = 0 otherwise.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So, for real-input FFTs, FFTW only gives you the non-negative frequencies of the DFT. Finally, if we want to avoid complex numbers entirely, we can use the \"real-to-real\" transform that returns the DFT in the halfcomplex format. This returns the frequencies in an order similar to the standard in-order manner discussed previously, but only returns the non-negative portion of the spectrum. Specifically, the FFTW manual shows that the order of outputs will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2  r_n2 i_(n+1)2-1  i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where r_k and i_k are the real and imaginary parts of component k, and division by 2 is rounded down. An example makes this a bit more clear. Let's imagine we have a signal of length 8, so n = 8. Then the output we'll get from FFTW will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2 r_3 r_4 i_3 i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"i_0 and i_4 are \"missing,\" but that doesn't bother us since we know that both of those are always zero for a real-input even-length DFT.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What if we had an odd-length input signal? Let's try n=9 this time. Then the output will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2 r_3 r_4 i_4 i_3 i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This time the i_4 component isn't \"missing,\" which is a good thing, since it's not zero.","category":"page"},{"location":"theory/#Time-Offset","page":"Theory","title":"Time Offset","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So far we've been assuming that the time t starts at 0. What if that's not true, i.e., that t_j = t_0 + jfracTn? Then","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2πmT right) left(t_0 + j fracTn right) = frac2πm t_0T + frac2πmjn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the signal is now","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t_j) = p_j = Acos(ωt_0 + jfracTn + φ) \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T + 2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T - 2πimath jmn \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T e^-2πimath jmn\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Next, we substitute the signal into the definition of the DFT:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            =fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T sum_j=0^n-1 e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T sum_j=0^n-1 e^-2πimath j(m+k)n \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"then use the same arguments we used before for the summations to find that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let's work on the non-zero hatp components a bit. First, the positive-m one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T n \n             = fracA2lefte^imath φ right e^2πimath m t_0T n \n             = fracA2lefte^imath φ + 2πimath m t_0T right n \n             = fracA2lefte^imath (φ + 2π m t_0T) right n \n             = fracA2leftcos(φ + 2π m t_0T) + imath sin(φ+ 2π m t_0T) right n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the negative-m one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T n \n                = fracA2lefte^-imath φ right e^-2πimath m t_0T n \n                = fracA2lefte^-imath φ - 2πimath m t_0T right n \n                = fracA2lefte^-imath (φ + 2π m t_0T) right n \n                = fracA2leftcos(φ + 2π m t_0T) - imath sin(φ+ 2π m t_0T) right n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So now, if we want to find A and φ from the hatp_m components a_r ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"a_r = fracA2cos(φ + 2π m t_0T)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and a_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"a_i = fracA2sin(φ + 2π m t_0T)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can use the same formula for A","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = frac2nsqrta_r^2 + a_i^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and a slightly modified version of the formula for φ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = arctan(a_ia_r) - 2π m t_0T","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"And we don't need to worry about the two special cases discussed previously, since the φ angle for both the mean and Nyquist components is always zero. What about the special cases we discussed previously (the mean and the Nyquist frequencies)? Obviously shifting the mean component shouldn't change anything. But what about the Nyquist frequency?","category":"page"},{"location":"theory/#Nyquist-Component-with-a-Time-Offset","page":"Theory","title":"Nyquist Component with a Time Offset","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We know from previous work that the odd-input length Nyquist component isn't special, so we'll ignore that case. So, for the even-input length Nyquist component, we'll start with the same signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T + 2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T - 2πimath jmn \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T e^-2πimath jmn\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and then say that m = n2, like previously","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath (n2) t_0T e^2πimath j(n2)n + fracA2left cos(φ) - imath sin(φ)right e^-2πimath (n2) t_0T e^-2πimath j(n2)n \n      = fracA2left cos(φ) + imath sin(φ)right e^πimath n t_0T e^πimath j + fracA2left cos(φ) - imath sin(φ)right e^-πimath n t_0T e^-πimath j \n      = fracA2lefte^imath φright e^πimath n t_0T e^πimath j + fracA2left e^-imath φright e^-πimath n t_0T e^-πimath j \n      = fracA2lefte^imath (φ + πn t_0T)right e^πimath j + fracA2left e^-imath (φ + πn t_0T)right e^-πimath j \n      = fracA2leftcos(φ + πn t_0T) + imath sin(φ + πn t_0T)right e^πimath j + fracA2left cos(φ + πn t_0T) - imath sin(φ + πn t_0T)right e^-πimath j \n      = Acos(φ + πn t_0T)e^πimath j \n      = Acos(φ + 2π (n2) t_0T)e^2πimath j (n2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So this means the Fourier transform is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatp_n2 = Acos(φ + 2π (n2) t_0T) n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so we can find","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = a_rn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = -2π(n2) t_0T","category":"page"},{"location":"theory/#What-if-the-signal-frequency-isn't-a-multiple-of-the-sampling-frequency?","page":"Theory","title":"What if the signal frequency isn't a multiple of the sampling frequency?","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Say we evaluate that function n times over a period T, just like before. But this time we will assume that ω = 2π(m+a)T where 0 lt a lt 1, i.e., that the period of our signal is not some integer fraction of the sampling period T. What will the Fourier transform of that be?","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We can reuse a bunch of our previous work. This expression for the signal p(t) still applies:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left cos(φ) + imath sin(φ)right e^imath ωt + fracA2left cos(φ) - imath sin(φ)right e^-imath ωt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"But now we just need to substitute our new expression for ω t_j,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2π(m+a)T right) left(j fracTn right) = frac2π(m+a)jn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which will give us","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath j(m+a)n + fracA2left cos(φ) - imath sin(φ)right e^-2πimath j(m+a)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, if we do the FFT:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m+a)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+a)n right) e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m+a-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+a+k)n right) \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m+a-k)n + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+a+k)n \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m-k)n e^2πimath ajn + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+k)n  e^2πimath ajn\nendaligned","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"CurrentModule = AMDocs","category":"page"},{"location":"sqa/#Software-Quality-Assurance","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"","category":"section"},{"location":"sqa/#Tests","page":"Software Quality Assurance","title":"Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticMetrics.jl uses the usual Julia testing framework to implement and run tests. The tests can be run locally after installing AcousticMetrics.jl, and are also run automatically on GitHub Actions.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"To run the tests locally, from the Julia REPL, type ] to enter the Pkg prompt, then","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(docs) pkg> test AcousticMetrics\n     Testing AcousticMetrics\nTest Summary:      | Pass  Total  Time\nFourier transforms |   16     16  9.0s\nTest Summary:     | Pass  Total  Time\nPressure Spectrum |  108    108  1.7s\nTest Summary:                  | Pass  Total  Time\nMean-squared Pressure Spectrum |   88     88  8.0s\nTest Summary:          | Pass  Total  Time\nPower Spectral Density |   88     88  0.9s\nTest Summary:              | Pass  Total  Time\nProportional Band Spectrum | 1066   1066  5.3s\nTest Summary: | Pass  Total  Time\nOASPL         |   16     16  0.3s\nTest Summary: | Pass  Total  Time\nA-weighting   |    8      8  0.5s\n     Testing AcousticMetrics tests passed \n\n(docs) pkg> ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(The output associated with installing all the dependencies the tests need isn't shown above.)","category":"page"},{"location":"sqa/#Signed-Commits","page":"Software Quality Assurance","title":"Signed Commits","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticMetrics.jl GitHub repository requires all commits to the main branch to be signed. See the GitHub docs on signing commits for more information.","category":"page"},{"location":"sqa/#Reporting-Bugs","page":"Software Quality Assurance","title":"Reporting Bugs","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Users can use the GitHub Issues feature to report bugs and submit feature requests.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AMDocs","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AcousticMetrics.jl is a Julia package for computing various metrics useful in acoustics. Currently implemented metrics include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Various narrowband spectra\nPressure amplitude\nMean-squared pressure amplitude (MSP)\nPower Spectral Density (PSD)\nPhase\nProportional band spectra\nApproximate octave and third-octave spectra\nExact proportional spectra of any octave fraction integer > 0.\nLazy representations of proportional band spectra constructed from either narrowband or proportional band spectra\nIntegrated metrics\nUnweighted and A-weighted Overall Sound Pressure Level (OASPL)","category":"page"}]
}
