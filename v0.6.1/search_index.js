var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = AMDocs","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [AcousticMetrics]","category":"page"},{"location":"api/#AcousticMetrics.AbstractNarrowbandSpectrum","page":"API","title":"AcousticMetrics.AbstractNarrowbandSpectrum","text":"AbstractNarrowbandSpectrum{IsEven,Tel} <: AbstractVector{Tel}\n\nSupertype for a generic narrowband acoustic metric which will behave as an immutable AbstractVector of element type Tel.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.AbstractPressureTimeHistory","page":"API","title":"AcousticMetrics.AbstractPressureTimeHistory","text":"AbstractPressureTimeHistory{IsEven}\n\nSupertype for a pressure time history, i.e., pressure as a function of time defined on evenly-spaced time samples.\n\nThe IsEven parameter is a Bool indicating if the length of the pressure time history is even or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.AbstractProportionalBands","page":"API","title":"AcousticMetrics.AbstractProportionalBands","text":"AbstractProportionalBands{NO,LCU,TF} <: AbstractVector{TF}\n\nAbstract type representing the exact proportional frequency bands with band fraction NO and eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveBands","page":"API","title":"AcousticMetrics.ApproximateOctaveBands","text":"ApproximateOctaveBands{LCU,TF} <: AbstractProportionalBands{3,LCU,TF}\n\nRepresentation of the approximate octave proportional frequency bands with eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateOctaveBands-Union{Tuple{Int64, Int64}, Tuple{LCU}} where LCU","page":"API","title":"AcousticMetrics.ApproximateOctaveBands","text":"ApproximateOctaveBands{LCU,TF}(bstart::Int, bend::Int)\n\nConstruct an ApproximateOctaveBands with eltype TF encomposing band numbers from bstart to bend.\n\nTF defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.ApproximateOctaveBands-Union{Tuple{TF}, Tuple{LCU}, Tuple{TF, TF}} where {LCU, TF}","page":"API","title":"AcousticMetrics.ApproximateOctaveBands","text":"ApproximateOctaveBands{LCU}(fstart::TF, fend::TF)\n\nConstruct an ApproximateOctaveBands with eltype TF encomposing the bands needed to completly extend over minimum frequency fstart and maximum frequency fend.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveBands","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveBands","text":"ApproximateThirdOctaveBands{LCU,TF} <: AbstractProportionalBands{3,LCU,TF}\n\nRepresentation of the approximate third-octave proportional frequency bands with eltype TF.\n\nThe LCU parameter can take one of three values:\n\n:lower: The struct returns the lower edges of each frequency band.\n:center: The struct returns the center of each frequency band.\n:upper: The struct returns the upper edges of each frequency band.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveBands-Union{Tuple{Int64, Int64}, Tuple{LCU}} where LCU","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveBands","text":"ApproximateThirdOctaveBands{LCU,TF}(bstart::Int, bend::Int)\n\nConstruct an ApproximateThirdOctaveBands with eltype TF encomposing band numbers from bstart to bend.\n\nTF defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.ApproximateThirdOctaveBands-Union{Tuple{TF}, Tuple{LCU}, Tuple{TF, TF}} where {LCU, TF}","page":"API","title":"AcousticMetrics.ApproximateThirdOctaveBands","text":"ApproximateThirdOctaveBands{LCU}(fstart::TF, fend::TF)\n\nConstruct an ApproximateThirdOctaveBands with eltype TF encomposing the bands needed to completly extend over minimum frequency fstart and maximum frequency fend.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.ExactOctaveCenterBands","page":"API","title":"AcousticMetrics.ExactOctaveCenterBands","text":"ExactOctaveCenterBands{TF}\n\nAlias for ExactProportionalBands{1,:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactOctaveLowerBands","page":"API","title":"AcousticMetrics.ExactOctaveLowerBands","text":"ExactOctaveLowerBands{TF}\n\nAlias for ExactProportionalBands{1,:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactOctaveUpperBands","page":"API","title":"AcousticMetrics.ExactOctaveUpperBands","text":"ExactOctaveUpperBands{TF}\n\nAlias for ExactProportionalBands{1,:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactProportionalBands","page":"API","title":"AcousticMetrics.ExactProportionalBands","text":"ExactProportionalBands{NO,LCU}(TF=Float64, bstart::Int, bend::Int)\n\nConstruct an ExactProportionalBands with eltype TF encomposing band numbers from bstart to bend.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactProportionalBands-Union{Tuple{TF}, Tuple{LCU}, Tuple{NO}, Tuple{TF, TF}} where {NO, LCU, TF}","page":"API","title":"AcousticMetrics.ExactProportionalBands","text":"ExactProportionalBands{NO,LCU}(fstart::TF, fend::TF)\n\nConstruct an ExactProportionalBands with eltype TF encomposing the bands needed to completly extend over minimum frequency fstart and maximum frequency fend.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.ExactThirdOctaveCenterBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveCenterBands","text":"ExactThirdOctaveCenterBands{TF}\n\nAlias for ExactProportionalBands{3,:center,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactThirdOctaveLowerBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveLowerBands","text":"ExactThirdOctaveLowerBands{TF}\n\nAlias for ExactProportionalBands{3,:lower,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ExactThirdOctaveUpperBands","page":"API","title":"AcousticMetrics.ExactThirdOctaveUpperBands","text":"ExactThirdOctaveUpperBands{TF}\n\nAlias for ExactProportionalBands{3,:upper,TF}\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumAmplitude","page":"API","title":"AcousticMetrics.MSPSpectrumAmplitude","text":"MSPSpectrumAmplitude(pth::AbstractPressureTimeHistory, hc=similar(pressure(pth)))\n\nConstruct a narrowband spectrum of the mean-squared pressure amplitude from a pressure time history.\n\nThe optional argument hc will be used to store the discrete Fourier transform of the pressure time history, and should have length of inputlength(pth).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumAmplitude-2","page":"API","title":"AcousticMetrics.MSPSpectrumAmplitude","text":"MSPSpectrumAmplitude(hc, dt, t0=zero(dt))\n\nConstruct a narrowband spectrum of the mean-squared pressure amplitude from the discrete Fourier transform in half-complex format hc, time step size dt, and initial time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumAmplitude-3","page":"API","title":"AcousticMetrics.MSPSpectrumAmplitude","text":"MSPSpectrumAmplitude{IsEven,Tel} <: AbstractNarrowbandSpectrum{IsEven,Tel}\n\nRepresentation of mean-squared pressure amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.MSPSpectrumAmplitude-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.MSPSpectrumAmplitude","text":"MSPSpectrumAmplitude(sm::AbstractNarrowbandSpectrum)\n\nConstruct a narrowband spectrum of the mean-squared pressure amplitude from another narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.MSPSpectrumPhase","page":"API","title":"AcousticMetrics.MSPSpectrumPhase","text":"MSPSpectrumPhase\n\nAlias for PressureSpectrumPhase.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityAmplitude","page":"API","title":"AcousticMetrics.PowerSpectralDensityAmplitude","text":"PressureSpectrumAmplitude(pth::AbstractPressureTimeHistory, hc=similar(pressure(pth)))\n\nConstruct a narrowband spectrum of the power spectral density amplitude from a pressure time history.\n\nThe optional argument hc will be used to store the discrete Fourier transform of the pressure time history, and should have length of inputlength(pth).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityAmplitude-2","page":"API","title":"AcousticMetrics.PowerSpectralDensityAmplitude","text":"PowerSpectralDensityAmplitude(hc, dt, t0=zero(dt))\n\nConstruct a narrowband spectrum of the power spectral density amplitude from the discrete Fourier transform in half-complex format hc, time step size dt, and initial time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityAmplitude-3","page":"API","title":"AcousticMetrics.PowerSpectralDensityAmplitude","text":"PowerSpectralDensityAmplitude{IsEven,Tel} <: AbstractNarrowbandSpectrum{IsEven,Tel}\n\nRepresentation of acoustic power spectral density amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PowerSpectralDensityAmplitude-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.PowerSpectralDensityAmplitude","text":"PressureSpectrumAmplitude(sm::AbstractNarrowbandSpectrum)\n\nConstruct a narrowband spectrum of the power spectral density amplitude from another narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.PowerSpectralDensityPhase","page":"API","title":"AcousticMetrics.PowerSpectralDensityPhase","text":"PowerSpectralDensityPhase\n\nAlias for PressureSpectrumPhase.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumAmplitude","page":"API","title":"AcousticMetrics.PressureSpectrumAmplitude","text":"PressureSpectrumAmplitude(pth::AbstractPressureTimeHistory, hc=similar(pressure(pth)))\n\nConstruct a narrowband spectrum of the pressure amplitude from a pressure time history.\n\nThe optional argument hc will be used to store the discrete Fourier transform of the pressure time history, and should have length of inputlength(pth).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumAmplitude-2","page":"API","title":"AcousticMetrics.PressureSpectrumAmplitude","text":"PressureSpectrumAmplitude(hc, dt, t0=zero(dt))\n\nConstruct a narrowband spectrum of the pressure amplitude from the discrete Fourier transform in half-complex format hc, time step size dt, and initial time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumAmplitude-3","page":"API","title":"AcousticMetrics.PressureSpectrumAmplitude","text":"PressureSpectrumAmplitude{IsEven,Tel} <: AbstractNarrowbandSpectrum{IsEven,Tel}\n\nRepresentation of acoustic pressure amplitude as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumAmplitude-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.PressureSpectrumAmplitude","text":"PressureSpectrumAmplitude(sm::AbstractNarrowbandSpectrum)\n\nConstruct a narrowband spectrum of the pressure amplitude from another narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.PressureSpectrumPhase","page":"API","title":"AcousticMetrics.PressureSpectrumPhase","text":"PressureSpectrumPhase(pth::AbstractPressureTimeHistory, hc=similar(pressure(pth)))\n\nConstruct a narrowband spectrum of the pressure phase from a pressure time history.\n\nThe optional argument hc will be used to store the discrete Fourier transform of the pressure time history, and should have length of inputlength(pth).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumPhase-2","page":"API","title":"AcousticMetrics.PressureSpectrumPhase","text":"PressureSpectrumPhase(hc, dt, t0=zero(dt))\n\nConstruct a narrowband spectrum of the pressure phase from the discrete Fourier transform in half-complex format hc, time step size dt, and initial time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumPhase-3","page":"API","title":"AcousticMetrics.PressureSpectrumPhase","text":"PressureSpectrumPhase{IsEven,Tel} <: AbstractNarrowbandSpectrum{IsEven,Tel}\n\nRepresentation of acoustic pressure phase as a function of narrowband frequency.\n\nThe IsEven parameter is a Bool indicating if the length of the spectrum is even or not, affecting how the Nyquist frequency is calculated.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureSpectrumPhase-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.PressureSpectrumPhase","text":"PressureSpectrumPhase(sm::AbstractNarrowbandSpectrum)\n\nConstruct a narrowband spectrum of the pressure phase from another narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.PressureTimeHistory","page":"API","title":"AcousticMetrics.PressureTimeHistory","text":"PressureTimeHistory(sm::AbstractNarrowbandSpectrum, p=similar(halfcomplex(sm)))\n\nConstruct a pressure time history from a narrowband spectrum sm.\n\nThe optional p argument will be used to store the pressure vector of the pressure time history, and should have length inputlength(sm).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureTimeHistory-2","page":"API","title":"AcousticMetrics.PressureTimeHistory","text":"PressureTimeHistory(p, dt, t0=zero(dt))\n\nConstruct a PressureTimeHistory from a vector of pressures p, time spacing dt, and initial time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.PressureTimeHistory-3","page":"API","title":"AcousticMetrics.PressureTimeHistory","text":"PressureTimeHistory{IsEven} <: AbstractPressureTimeHistory{IsEven}\n\nPressure as a function of time defined on evenly-spaced time samples.\n\nThe IsEven parameter is a Bool indicating if the length of the pressure time history is even or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ProportionalBandSpectrum","page":"API","title":"AcousticMetrics.ProportionalBandSpectrum","text":"ProportionalBandSpectrum{NO,TF,TAmp,TBandsL,TBandsC,TBandsU}\n\nRepresentation of a proportional band spectrum with octave fraction NO and eltype TF.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticMetrics.ProportionalBandSpectrum-Tuple{Type{<:AcousticMetrics.AbstractProportionalBands}, AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.ProportionalBandSpectrum","text":"ProportionalBandSpectrum(TBands::Type{<:AbstractProportionalBands}, sm::AbstractNarrowbandSpectrum)\n\nConstruct a ProportionalBandSpectrum using a proportional band TBands and narrowband spectrum sm.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.OASPL-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.OASPL","text":"OASPL(ap::AbstractNarrowbandSpectrum)\n\nReturn the overall sound pressure level of a narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.OASPL-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.OASPL","text":"OASPL(ap::AbstractPressureTimeHistory)\n\nReturn the overall sound pressure level of a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.W_A-Tuple{Any}","page":"API","title":"AcousticMetrics.W_A","text":"W_A(f::AbstractFloat)\n\nCalculate the A-weighting factor for a frequency f in Hertz.\n\nTaken from the ANOPP2 Acoustics Analysis API Reference Manual.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.dft_hc2r-Tuple{AbstractVector}","page":"API","title":"AcousticMetrics.dft_hc2r","text":"dft_hc2r(x::AbstractVector)\n\nCalculate the inverse discrete Fourier transform of a real-input DFT.\n\nThis is the inverse of dft_r2hc, except for a factor of N, where N is the length of the input (and output), since FFTW computes an \"unnormalized\" FFT.\n\nSee http://www.fftw.org/fftw3doc/The-1d-Real002ddata-DFT.html#The-1d-Real002ddata-DFT and http://www.fftw.org/fftw3doc/The-Halfcomplex_002dformat-DFT.html for details.\n\nOnly use this for checking the derivatives of the FFT routines (should work fine, just slow).\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.dft_r2hc-Tuple{AbstractVector}","page":"API","title":"AcousticMetrics.dft_r2hc","text":"dft_r2hc(x::AbstractVector)\n\nCalculate the real-input discrete Fourier transform, returning the result in the \"half-complex\" format.\n\nSee http://www.fftw.org/fftw3doc/The-1d-Real002ddata-DFT.html#The-1d-Real002ddata-DFT and http://www.fftw.org/fftw3doc/The-Halfcomplex_002dformat-DFT.html for details.\n\nOnly use this for checking the derivatives of the FFT routines (should work fine, just slow).\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.frequency-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.frequency","text":"frequency(sm::AbstractNarrowbandSpectrum)\n\nReturn a vector of frequencies associated with the narrowband spectrum.\n\nThe frequencies are calculated using the rfftfreq function in the FFTW.jl package.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.halfcomplex-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.halfcomplex","text":"halfcomplex(sm::AbstractNarrowbandSpectrum)\n\nReturn a vector of the discrete Fourier transform of the pressure time history in half-complex format.\n\nSee the FFTW docs for the definition of the halfcomplex format.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.inputlength-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.inputlength","text":"inputlength(sm::AbstractNarrowbandSpectrum)\n\nReturn a number of pressure time samples associated with a narrowband spectrum.\n\nThis is also the length of the discrete Fourier transform associated with the spectrum in half-complex format.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.inputlength-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.inputlength","text":"inputlength(pth::AbstractPressureTimeHistory)\n\nReturn a number of pressure samples associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.irfft!","page":"API","title":"AcousticMetrics.irfft!","text":"irfft!(y, x, cache=nothing)\n\nCalculate the inverse FFT of `x` and store the result in in `y`, where `x` is in the half-complex format.\n\nJust a wrapper of `FFTW.r2r!(y, FFTW.HC2R)`. The `cache` argument is\noptional and not used, and is included to keep the function signiture the\nsame as the method that takes `Vector`s of `Dual`s.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.pressure-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.pressure","text":"pressure(pth::AbstractPressureTimeHistory)\n\nReturn a vector of pressures associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.rfft!","page":"API","title":"AcousticMetrics.rfft!","text":"rfft!(y, x, cache=nothing)\n\nCalculate the real-input FFT of `x` and store the result in half-complex format in `y`.\n\nJust a wrapper of `FFTW.r2r!(y, FFTW.R2HC)`. The `cache` argument is\noptional and not used, and is included to keep the function signiture the\nsame as the method that takes `Vector`s of `Dual`s.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticMetrics.samplerate-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.samplerate","text":"samplerate(sm::AbstractNarrowbandSpectrum)\n\nReturn the sample rate (aka the inverse of the time step size) associated with a narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.starttime-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.starttime","text":"starttime(sm::AbstractNarrowbandSpectrum)\n\nReturn the initial time t0 associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.starttime-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.starttime","text":"starttime(pth::AbstractPressureTimeHistory)\n\nReturn the initial time t0 associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.time-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.time","text":"time(pth::AbstractPressureTimeHistory)\n\nReturn a vector of times associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.timestep-Tuple{AcousticMetrics.AbstractNarrowbandSpectrum}","page":"API","title":"AcousticMetrics.timestep","text":"timestep(sm::AbstractNarrowbandSpectrum)\n\nReturn the time step size dt associated with a narrowband spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticMetrics.timestep-Tuple{AcousticMetrics.AbstractPressureTimeHistory}","page":"API","title":"AcousticMetrics.timestep","text":"timestep(pth::AbstractPressureTimeHistory)\n\nReturn the time step size dt associated with a pressure time history.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{AcousticMetrics.ApproximateOctaveBands, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(bands::ApproximateOctaveBands{LCU}, i::Int) where {LCU}\n\nReturn the lower, center, or upper frequency (depending on the value of LCU) associated with the i-th proportional band frequency covered by bands.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{AcousticMetrics.ApproximateThirdOctaveBands, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(bands::ApproximateThirdOctaveBands{LCU}, i::Int) where {LCU}\n\nReturn the lower, center, or upper frequency (depending on the value of LCU) associated with the i-th proportional band frequency covered by bands.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{AcousticMetrics.ExactProportionalBands, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(bands::ExactProportionalBands{NO,LCU}, i::Int) where {NO,LCU}\n\nReturn the lower, center, or upper frequency (depending on the value of LCU) associated with the i-th proportional band frequency covered by bands.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{AcousticMetrics.ProportionalBandSpectrum, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(pbs::ProportionalBandSpectrum, i::Int)\n\nReturn the proportional band spectrum amplitude for the ith non-zero band in pbs.\n\n\n\n\n\n","category":"method"},{"location":"theory/","page":"Theory","title":"Theory","text":"CurrentModule = AMDocs","category":"page"},{"location":"theory/#AcousticMetrics.jl","page":"Theory","title":"AcousticMetrics.jl","text":"","category":"section"},{"location":"theory/#The-Fourier-Transform","page":"Theory","title":"The Fourier Transform","text":"","category":"section"},{"location":"theory/#The-Basics","page":"Theory","title":"The Basics","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"AcousticMetrics.jl uses the FFTW library, a very popular implementation of the fast Fourier transform (FFT) algorithm. The FFT is a method of computing the discrete Fourier transform (DFT) that reduces the computational complexity from n^2 to n log(n), where n is the length of the input to the transform. FFTW's definition of the discrete Fourier transform is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  y_k = sum_j=0^n-1 x_j e^-2 pi imath jkn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where imath=sqrt-1.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The goal of a Fourier transform is to take a function (let's call it a \"signal\") and express it as a sum of sinusoids. Let's imagine we have a very simple signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we call A the amplitude, ω the frequency, and φ the phase. AcousticAnalogies.jl is interested in (surprise!) acoustics, which are real numbers, so we'll assume that A, ω, and φ are all real. Say we evaluate that function n times over a period T, and assume that ω = 2πmT, i.e., that the period of our signal is some integer fraction of the sampling period T, since","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"frac2 πω = frac2 πfrac2πmT = fracTm","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We'll refer to each of those samples as p_j = p(t_j), where t_j is the time at sample j and j is an index from 0 to n-1.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What is the discrete Fourier transform of our signal p_j? We should be able to figure that out if we can express our signal p(t) as something that looks like FFTW's definition of the DFT. How can we do that? Well, first we need to remember that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"cos(α+β) = cos(α)cos(β) - sin(α)sin(β)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which lets us rewrite our signal as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ) = Aleft cos(ωt)cos(φ) - sin(ωt)sin(φ) right = A cos(φ)cos(ωt) - Asin(φ)sin(ωt)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, if we also remember that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"e^ix = cos(x) + imath sin(x)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can replace sin(ωt) with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sin(ωt) = frace^imath ωt - e^-imath ωt2imath = frac-imath e^imath ωt + imath e^-imath ωt2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and cos(ωt) with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"cos(ωt) = frace^imath ωt + e^-imath ωt2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Throw all that together and we get","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left cos(φ) + imath sin(φ)right e^imath ωt + fracA2left cos(φ) - imath sin(φ)right e^-imath ωt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is looking much closer to the definition of the DFT that we started with. Next thing we need to do is realize that since we've sampled our signal p(t) at n different times, equally spaced, over a time period T, then we can replace t with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"t_j = j fracTn = j Δt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Tn is Δt, the time step size. We've previously said that ω=frac2πmT, which implies that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2πmT right) left(j fracTn right) = frac2πmjn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So if we throw that in there, we find","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath jmn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"That's very close to the DFT definition. So what happens if we evaluate the DFT of that last expression? We'll call the discrete Fourier transform of the signal hatp_k. So...","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath jmn + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath jmn right) e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+k)n right) \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+k)n \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Pretty close now. Let's think about those two summations in the last expression. First assume that m - k = q ne 0, where m and k are both integers. Then the first sum would be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-k)n = sum_j=0^n-1 e^2πimath jqn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"That's a signal that has period","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"frac2π2πqn = nq","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"that we're sampling n times. So we're sampling a sinusoid an integer number of times over its period, and summing it up. That will give us... zero. Same thing will happen to the second sum if m+k=r ne 0: we'll also get zero. So now we just have to figure out what happens when m - k = 0 and m + k = 0, i.e., when k  m. Let's try k = m first. The first sum will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-m)n = sum_j=0^n-1 e^0 = sum_j=0^n-1 1 = n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the second sum will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^-2πimath j(m+m)n = sum_j=0^n-1 e^-4πimath jmn = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"from the previous discussion, since m+k=2m ne 0.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For k = -m, the first sum will be zero, since m - -m = 2m ne 0, and the second sum will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  sum_j=0^n-1 e^2πimath j(m-m))n = n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"again.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Great! So now we finally can write down the DFT of our example signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ) = A cosleft(leftfrac2πmTrightt+φright)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which is (wish I could figure out how to do the cases LaTeX environment)...","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/#Some-Special-Cases","page":"Theory","title":"Some Special Cases","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"There are two special cases that we need to consider: the mean component and the Nyquist component of the DFT. Let's try the mean component first.","category":"page"},{"location":"theory/#The-Mean-Component","page":"Theory","title":"The Mean Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So imagine if we start out with the same signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"but say that ω = 0. Since ω = 2πmT, that implies that m = 0 also. But anyway, let's rewrite that in terms of powers of e:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^imath ωt + fracA2leftcos(φ) - imath sin(φ) right e^-imath ωt \n     = fracA2leftcos(φ) + imath sin(φ) right e^0 + fracA2leftcos(φ) - imath sin(φ) right e^0\n     = fracA2left2cos(φ)right\n     = Acos(φ)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What happens if we plug that into the definition of the discrete Fourier transform? We'll, it's not hard to see that we'll get","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_0 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So the two takeaways are:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the mean component doesn't contain a frac12 factor\nthe mean component is always real","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Next, the Nyquist frequency component.","category":"page"},{"location":"theory/#Nyquist-Component","page":"Theory","title":"Nyquist Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Nyquist component is the one with two samples per period, which corresponds to k=n2 in the DFT definition. It is the highest frequency component that the DFT can resolve. So that means our signal will look like","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath jmn + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath jmn \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now here's where things get a bit tricky. We've got a fracn2n term that we'd love to replace with frac12. That works fine if n is even, but what if n is odd? We'll have to look at both cases. First, the even case.","category":"page"},{"location":"theory/#Nyquist-Component-with-Even-Length-Input","page":"Theory","title":"Nyquist Component with Even-Length Input","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If n is even, then we can do","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n \n     = fracA2leftcos(φ) + imath sin(φ) right e^πimath j + fracA2leftcos(φ) - imath sin(φ) right e^-πimath j\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and then realize that e^πimath j = e^-πimath j = left(-1right)^j, which let's us simplify a bit further to","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left2cos(φ)e^πimath jright = Acos(φ)e^πimath j","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next step is to think about which components of the DFT we need to worry about. If we shove that into the DFT, we'll need to just focus on the e^-2πimath j (n2)n = e^-πimath j component of the DFT, and we'll eventually end up with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_n2 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so the takeaways are identical to the mean component:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the Nyquist component for n even doesn't contain a frac12 factor\nthe Nyquist component for n even is always real","category":"page"},{"location":"theory/#Nyquist-Component-with-Odd-Length-Input","page":"Theory","title":"Nyquist Component with Odd-Length Input","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So, we're starting with ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t) = A cos(ωt+φ) \n     = fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(fracn2)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(fracn2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, the trick here is that there is no Nyquist frequency component with an odd-input DFT. We'll never end up with e^2πimath j(fracn2)n = e^πimath components in the DFT definition, since n is odd. For example, if n=9, the k in the original definition of the DFT","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  y_k = sum_j=0^n-1 x_j e^-2 pi imath jkn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"will never take on the value n2, since that would be 4frac12 and k is an integer. So this special case isn't special for odd input lengths.","category":"page"},{"location":"theory/#Order-of-Outputs","page":"Theory","title":"Order of Outputs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We're almost ready to compare our example signal to the output of the FFTW library. The last thing we need to think about is how FFTW's output is ordered. FFT libraries have different conventions, but here is what FFTW does:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note also that we use the standard “in-order” output ordering—the k-th output corresponds to the frequency k/n (or k/T, where T is your total sampling period). For those who like to think in terms of positive and negative frequencies, this means that the positive frequencies are stored in the first half of the output and the negative frequencies are stored in backwards order in the second half of the output. (The frequency -k/n is the same as the frequency (n-k)/n.)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So for our original example signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p(t) = A cos(ωt+φ) \n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we would expect hatp_m to appear in the 1+m position (since m starts from 0, but the first \"position\" is 1 for Julia arrays), and hatp_-m to appear in the 1+n-m position. But things get a bit more complicated if we use a real-input FFT (which AcousticMetrics.jl does). See the next section.","category":"page"},{"location":"theory/#Real-Input-FFTs-and-Half-Complex-Format","page":"Theory","title":"Real-Input FFTs and Half-Complex Format","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we look back at the results for the DFT of our simple signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p(t) = A cos(ωt+φ) \n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can't help but notice that the negative and positive frequency results are closely related. If we know one, we can figure out the other. And if we want to find A and φ, we just need either the positive or negative result. For example, if a_r and a_i are the real and imaginary parts of hatp_m, respectively, then","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = frac2nsqrta_r^2 + a_i^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = arctan(a_ia_r)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the Nyquist frequency, though, we know that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nhatp_n2 = Acos(φ)n \nhatp_k = 0 textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so a_r = Acos(φ)n and a_i = 0. We have only one non-zero component, so we'll have to define ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = a_rn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Or, wait, maybe it would be better to make A = abs(a_r)/n and φ = π if a_r < 0, and φ = 0 otherwise.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So, for real-input FFTs, FFTW only gives you the non-negative frequencies of the DFT. Finally, if we want to avoid complex numbers entirely, we can use the \"real-to-real\" transform that returns the DFT in the halfcomplex format. This returns the frequencies in an order similar to the standard in-order manner discussed previously, but only returns the non-negative portion of the spectrum. Specifically, the FFTW manual shows that the order of outputs will be","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2  r_n2 i_(n+1)2-1  i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where r_k and i_k are the real and imaginary parts of component k, and division by 2 is rounded down. An example makes this a bit more clear. Let's imagine we have a signal of length 8, so n = 8. Then the output we'll get from FFTW will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2 r_3 r_4 i_3 i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"i_0 and i_4 are \"missing,\" but that doesn't bother us since we know that both of those are always zero for a real-input even-length DFT.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What if we had an odd-length input signal? Let's try n=9 this time. Then the output will be ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r_0 r_1 r_2 r_3 r_4 i_4 i_3 i_2 i_1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This time the i_4 component isn't \"missing,\" which is a good thing, since it's not zero.","category":"page"},{"location":"theory/#Time-Offset","page":"Theory","title":"Time Offset","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"So far we've been assuming that the time t starts at 0. What if that's not true, i.e., that t_j = t_0 + jfracTn? Then","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2πmT right) left(t_0 + j fracTn right) = frac2πm t_0T + frac2πmjn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the signal is now","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t_j) = p_j = Acos(ωt_0 + jfracTn + φ) \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T + 2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T - 2πimath jmn \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T e^-2πimath jmn\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Next, we substitute the signal into the definition of the DFT:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            =fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T sum_j=0^n-1 e^2πimath j(m-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T sum_j=0^n-1 e^-2πimath j(m+k)n \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"then use the same arguments we used before for the summations to find that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T n \n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T n \n  hatp_k  = 0textotherwise\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let's work on the non-zero hatp components a bit. First, the positive-m one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_m  = fracA2leftcos(φ) + imath sin(φ) right e^2πimath m t_0T n \n             = fracA2lefte^imath φ right e^2πimath m t_0T n \n             = fracA2lefte^imath φ + 2πimath m t_0T right n \n             = fracA2lefte^imath (φ + 2π m t_0T) right n \n             = fracA2leftcos(φ + 2π m t_0T) + imath sin(φ+ 2π m t_0T) right n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the negative-m one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_-m  = fracA2leftcos(φ) - imath sin(φ) right e^-2πimath m t_0T n \n                = fracA2lefte^-imath φ right e^-2πimath m t_0T n \n                = fracA2lefte^-imath φ - 2πimath m t_0T right n \n                = fracA2lefte^-imath (φ + 2π m t_0T) right n \n                = fracA2leftcos(φ + 2π m t_0T) - imath sin(φ+ 2π m t_0T) right n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So now, if we want to find A and φ from the hatp_m components a_r ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"a_r = fracA2cos(φ + 2π m t_0T)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and a_i","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"a_i = fracA2sin(φ + 2π m t_0T)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we can use the same formula for A","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = frac2nsqrta_r^2 + a_i^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and a slightly modified version of the formula for φ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = arctan(a_ia_r) - 2π m t_0T","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"And we don't need to worry about the two special cases discussed previously, since the φ angle for both the mean and Nyquist components is always zero. What about the special cases we discussed previously (the mean and the Nyquist frequencies)? Obviously shifting the mean component shouldn't change anything. But what about the Nyquist frequency?","category":"page"},{"location":"theory/#Nyquist-Component-with-a-Time-Offset","page":"Theory","title":"Nyquist Component with a Time Offset","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We know from previous work that the odd-input length Nyquist component isn't special, so we'll ignore that case. So, for the even-input length Nyquist component, we'll start with the same signal","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\np(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T + 2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T - 2πimath jmn \n             = fracA2left cos(φ) + imath sin(φ)right e^2πimath m t_0T e^2πimath jmn + fracA2left cos(φ) - imath sin(φ)right e^-2πimath m t_0T e^-2πimath jmn\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and then say that m = n2, like previously","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath (n2) t_0T e^2πimath j(n2)n + fracA2left cos(φ) - imath sin(φ)right e^-2πimath (n2) t_0T e^-2πimath j(n2)n \n      = fracA2left cos(φ) + imath sin(φ)right e^πimath n t_0T e^πimath j + fracA2left cos(φ) - imath sin(φ)right e^-πimath n t_0T e^-πimath j \n      = fracA2lefte^imath φright e^πimath n t_0T e^πimath j + fracA2left e^-imath φright e^-πimath n t_0T e^-πimath j \n      = fracA2lefte^imath (φ + πn t_0T)right e^πimath j + fracA2left e^-imath (φ + πn t_0T)right e^-πimath j \n      = fracA2leftcos(φ + πn t_0T) + imath sin(φ + πn t_0T)right e^πimath j + fracA2left cos(φ + πn t_0T) - imath sin(φ + πn t_0T)right e^-πimath j \n      = Acos(φ + πn t_0T)e^πimath j \n      = Acos(φ + 2π (n2) t_0T)e^2πimath j (n2)n\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"So this means the Fourier transform is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatp_n2 = Acos(φ + 2π (n2) t_0T) n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and so we can find","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A = a_rn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"φ = -2π(n2) t_0T","category":"page"},{"location":"theory/#What-if-the-signal-frequency-isn't-a-multiple-of-the-sampling-frequency?","page":"Theory","title":"What if the signal frequency isn't a multiple of the sampling frequency?","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = A cos(ωt+φ)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Say we evaluate that function n times over a period T, just like before. But this time we will assume that ω = 2π(m+a)T where 0 lt a lt 1, i.e., that the period of our signal is not some integer fraction of the sampling period T. What will the Fourier transform of that be?","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We can reuse a bunch of our previous work. This expression for the signal p(t) still applies:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t) = fracA2left cos(φ) + imath sin(φ)right e^imath ωt + fracA2left cos(φ) - imath sin(φ)right e^-imath ωt","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"But now we just need to substitute our new expression for ω t_j,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ω t_j = left( frac2π(m+a)T right) left(j fracTn right) = frac2π(m+a)jn","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which will give us","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p(t_j) = p_j = fracA2left cos(φ) + imath sin(φ)right e^2πimath j(m+a)n + fracA2left cos(φ) - imath sin(φ)right e^-2πimath j(m+a)n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, if we do the FFT:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n  hatp_k = sum_j=0^n-1 p_j e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m+a)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+a)n right) e^-2 pi imath jkn \n            = sum_j=0^n-1 left( fracA2leftcos(φ) + imath sin(φ) right e^2πimath j(m+a-k)n + fracA2leftcos(φ) - imath sin(φ) right e^-2πimath j(m+a+k)n right) \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m+a-k)n + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+a+k)n \n            =fracA2leftcos(φ) + imath sin(φ) right sum_j=0^n-1 e^2πimath j(m-k)n e^2πimath ajn + fracA2leftcos(φ) - imath sin(φ) right sum_j=0^n-1 e^-2πimath j(m+k)n  e^2πimath ajn\nendaligned","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"CurrentModule = AMDocs","category":"page"},{"location":"sqa/#Software-Quality-Assurance","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"","category":"section"},{"location":"sqa/#Tests","page":"Software Quality Assurance","title":"Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticMetrics.jl uses the usual Julia testing framework to implement and run tests. The tests can be run locally after installing AcousticMetrics.jl, and are also run automatically on GitHub Actions.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"To run the tests locally, from the Julia REPL, type ] to enter the Pkg prompt, then","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(docs) pkg> test AcousticMetrics\n     Testing AcousticMetrics\nTest Summary:      | Pass  Total  Time\nFourier transforms |   16     16  9.0s\nTest Summary:     | Pass  Total  Time\nPressure Spectrum |  108    108  1.7s\nTest Summary:                  | Pass  Total  Time\nMean-squared Pressure Spectrum |   88     88  8.0s\nTest Summary:          | Pass  Total  Time\nPower Spectral Density |   88     88  0.9s\nTest Summary:              | Pass  Total  Time\nProportional Band Spectrum | 1066   1066  5.3s\nTest Summary: | Pass  Total  Time\nOASPL         |   16     16  0.3s\nTest Summary: | Pass  Total  Time\nA-weighting   |    8      8  0.5s\n     Testing AcousticMetrics tests passed \n\n(docs) pkg> ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(The output associated with installing all the dependencies the tests need isn't shown above.)","category":"page"},{"location":"sqa/#Signed-Commits","page":"Software Quality Assurance","title":"Signed Commits","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticMetrics.jl GitHub repository requires all commits to the main branch to be signed. See the GitHub docs on signing commits for more information.","category":"page"},{"location":"sqa/#Reporting-Bugs","page":"Software Quality Assurance","title":"Reporting Bugs","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Users can use the GitHub Issues feature to report bugs and submit feature requests.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AMDocs","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AcousticMetrics.jl is a Julia package for computing various metrics useful in acoustics. Currently implemented metrics include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Various narrowband spectra\nPressure amplitude\nMean-squared pressure amplitude (MSP)\nPower Spectral Density (PSD)\nPhase\nProportional band spectra\nApproximate octave and third-octave spectra\nExact proportional spectra of any octave fraction > 0.\nIntegrated metrics\nUnweighted and A-weighted Overall Sound Pressure Level (OASPL)","category":"page"}]
}
